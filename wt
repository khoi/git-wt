#!/bin/bash
set -euo pipefail

usage() {
  cat <<'USAGE'
wt - A simple git worktree sugar

Usage:
  wt [--base-dir <dir>] <command>

Global Flags:
  --base-dir <dir>  base dir override
  -h, --help        show help

Commands:
  switch <branch> create or open a workspace
  sw <branch>     alias for switch
  exec <branch>   open a workspace and run a command
  sync [from to]  copy files between worktrees
  ls              list workspaces
  archive <branch> save workspace state and remove worktree
  unarchive <branch> restore workspace from archive
  rm <branch>     remove a workspace
  merge <target>  squash, rebase, and merge to target
  here            print current workspace branch
  base            print base dir
  root            print main worktree path
  completion      print shell completion
  help [command]  show help
USAGE
}

switch_usage() {
  cat <<'USAGE'
wt switch|sw <branch>

Flags:
  --from <ref>      base ref for new branch
  --path <dir>      explicit worktree path
  --fetch           fetch remotes before resolving --from
  --copy-all        copy all files to new worktree
  --copy-ignored    copy gitignored files to new worktree
  --copy-untracked  copy untracked files to new worktree
  --copy-modified   copy modified files to new worktree
  -f, --force       overwrite existing destination files
  -v, --verbose     print copy progress
  -h, --help        show help
USAGE
}

exec_usage() {
  cat <<'USAGE'
wt exec <branch> -- <cmd...>

Flags:
  --from <ref>    base ref for new branch
  --path <dir>    explicit worktree path
  --fetch         fetch remotes before resolving --from
  -h, --help      show help
USAGE
}

sync_usage() {
  cat <<'USAGE'
wt sync [<from-branch> <to-branch>]

Defaults to primary worktree -> current worktree.

Flags:
  --copy-all        copy all files
  --copy-ignored    copy gitignored files
  --copy-untracked  copy untracked files
  --copy-modified   copy modified files
  -f, --force       overwrite existing destination files
  -v, --verbose     print copy progress
  -n, --dry-run     show files that would be copied
  -h, --help        show help
USAGE
}

ls_usage() {
  cat <<'USAGE'
wt ls

Lists active worktrees and archived entries.

Flags:
  --plain         tab-delimited output
  --json          JSON output
  -h, --help      show help
USAGE
}

rm_usage() {
  cat <<'USAGE'
wt rm <branch>

Flags:
  -f, --force     remove even if dirty
  -h, --help      show help
USAGE
}

archive_usage() {
  cat <<'USAGE'
wt archive <branch>

Flags:
  -h, --help      show help
USAGE
}

unarchive_usage() {
  cat <<'USAGE'
wt unarchive <branch>

Flags:
  --path <dir>    explicit worktree path
  -h, --help      show help
USAGE
}

merge_usage() {
  cat <<'USAGE'
wt merge <target>

Squash, rebase, and fast-forward merge into target branch.

Flags:
  --no-squash   preserve individual commits
  --no-rebase   skip rebase (fail if not rebased)
  --no-commit   skip committing uncommitted changes
  -h, --help    show help
USAGE
}

here_usage() {
  cat <<'USAGE'
wt here
USAGE
}

base_usage() {
  cat <<'USAGE'
wt base
USAGE
}

root_usage() {
  cat <<'USAGE'
wt root
USAGE
}

completion_usage() {
  cat <<'USAGE'
wt completion <shell>

Shells:
  bash
  zsh
  fish
USAGE
}

die() {
  printf 'error: %s\n' "$1" >&2
  exit 1
}

BASE_DIR_OVERRIDE=""
OPEN_PATH_RESULT=""

require_repo() {
  local err
  if ! err=$(git rev-parse --git-dir 2>&1); then
    printf '%s\n' "$err" >&2
    die "not a git repository"
  fi
}

common_git_dir_abs() {
  local common
  common=$(git rev-parse --git-common-dir)
  local target
  case "$common" in
  /*) target="$common" ;;
  *) target="$(abs_path "$common")" ;;
  esac
  if [ -d "$target" ]; then
    (cd "$target" && pwd -P)
    return
  fi
  normalize_dir "$target"
}

repo_is_bare() {
  local is_bare
  if [ -n "${1:-}" ]; then
    is_bare=$(git --git-dir "$1" rev-parse --is-bare-repository)
  else
    is_bare=$(git rev-parse --is-bare-repository)
  fi
  [ "$is_bare" = "true" ]
}

canonical_worktree_path() {
  local path="$1"
  local resolved
  if resolved=$(git -C "$path" rev-parse --show-toplevel 2>/dev/null); then
    normalize_dir "$resolved"
    return
  fi
  normalize_dir "$path"
}

main_worktree_path() {
  local common
  common=$(common_git_dir_abs)
  if repo_is_bare; then
    printf '%s\n' "$common"
    return
  fi
  local path="" is_bare=0
  while IFS= read -r line || [ -n "$line" ]; do
    if [ -z "$line" ]; then
      if [ -n "$path" ] && [ "$is_bare" -eq 0 ]; then
        canonical_worktree_path "$path"
        return
      fi
      path=""
      is_bare=0
      continue
    fi
    case "$line" in
    worktree\ *) path="${line#worktree }" ;;
    bare) is_bare=1 ;;
    esac
  done < <(git worktree list --porcelain)
  if [ -n "$path" ] && [ "$is_bare" -eq 0 ]; then
    canonical_worktree_path "$path"
    return
  fi
  git rev-parse --show-toplevel
}

primary_worktree_path() {
  local root="$1"
  local entry
  while IFS= read -r entry; do
    [ -n "$entry" ] || continue
    local path head branch is_bare
    parse_worktree_entry "$entry"
    if [ "$is_bare" = "0" ] && [ -d "$path" ]; then
      printf '%s\n' "$path"
      return 0
    fi
  done < <(worktree_entries "$root")
  return 1
}

copy_source_path() {
  local root="$1"
  if repo_is_bare; then
    primary_worktree_path "$root" || die "no linked worktree found for copy operations"
    return
  fi
  printf '%s\n' "$root"
}

abs_path() {
  local path="$1"
  case "$path" in
  /*) printf '%s\n' "$path" ;;
  *) printf '%s/%s\n' "$(pwd -P)" "$path" ;;
  esac
}

normalize_dir() {
  local path="$1"
  if [ "$path" != "/" ]; then
    path="${path%/}"
  fi
  printf '%s\n' "$path"
}

base_dir() {
  local root="$1"
  local override="$2"
  local chosen
  chosen="${GIT_WT_BASE:-}"
  if [ -n "$override" ]; then
    chosen="$override"
  fi
  if [ -z "$chosen" ]; then
    normalize_dir "$(abs_path "$root/.worktrees")"
    return
  fi
  case "$chosen" in
  /*) normalize_dir "$(abs_path "$chosen")" ;;
  *) normalize_dir "$(abs_path "$root/$chosen")" ;;
  esac
}

resolve_path() {
  local root="$1"
  local path="$2"
  case "$path" in
  /*) abs_path "$path" ;;
  *) abs_path "$root/$path" ;;
  esac
}

worktree_entries() {
  local root="$1"
  local path="" head="" branch="" is_bare=0
  while IFS= read -r line || [ -n "$line" ]; do
    if [ -z "$line" ]; then
      if [ -n "$path" ]; then
        local output_path="$path"
        if [ "$is_bare" -eq 0 ]; then
          output_path=$(canonical_worktree_path "$path")
        fi
        printf '%s\t%s\t%s\t%s\n' "$output_path" "$head" "$branch" "$is_bare"
      fi
      path=""
      head=""
      branch=""
      is_bare=0
      continue
    fi
    local key value
    key=${line%% *}
    value=${line#* }
    case "$key" in
    worktree) path="$value" ;;
    HEAD) head="$value" ;;
    branch) branch="${value#refs/heads/}" ;;
    detached) branch="" ;;
    bare) is_bare=1 ;;
    esac
  done < <(git -C "$root" worktree list --porcelain)
  if [ -n "$path" ]; then
    local output_path="$path"
    if [ "$is_bare" -eq 0 ]; then
      output_path=$(canonical_worktree_path "$path")
    fi
    printf '%s\t%s\t%s\t%s\n' "$output_path" "$head" "$branch" "$is_bare"
  fi
}

parse_worktree_entry() {
  local entry="$1"
  local rest
  path=${entry%%$'\t'*}
  rest=${entry#*$'\t'}
  head=${rest%%$'\t'*}
  rest=${rest#*$'\t'}
  branch=${rest%%$'\t'*}
  is_bare=${rest#*$'\t'}
}

find_worktree_by_branch() {
  local root="$1"
  local target_branch="$2"
  local entry
  while IFS= read -r entry; do
    local path head branch is_bare
    parse_worktree_entry "$entry"
    if [ "$is_bare" = "1" ]; then
      continue
    fi
    if [ "$branch" = "$target_branch" ]; then
      printf '%s\n' "$path"
      return 0
    fi
  done < <(worktree_entries "$root")
  return 1
}

find_worktree_by_path() {
  local root="$1"
  local target="$2"
  local entry
  while IFS= read -r entry; do
    local path head branch is_bare
    parse_worktree_entry "$entry"
    if [ "$path" = "$target" ]; then
      printf '%s\n' "$path"
      return 0
    fi
    if [ -d "$path" ] && [ -d "$target" ] && [ "$path" -ef "$target" ]; then
      printf '%s\n' "$path"
      return 0
    fi
  done < <(worktree_entries "$root")
  return 1
}

archive_branch_key() {
  local root="$1"
  local branch="$2"
  printf '%s' "$branch" | git -C "$root" hash-object --stdin
}

archive_ref_prefix() {
  local root="$1"
  local branch="$2"
  printf 'refs/wt/archive/%s\n' "$(archive_branch_key "$root" "$branch")"
}

archive_meta_ref() {
  local root="$1"
  local branch="$2"
  printf '%s/meta\n' "$(archive_ref_prefix "$root" "$branch")"
}

archive_index_ref() {
  local root="$1"
  local branch="$2"
  printf '%s/index\n' "$(archive_ref_prefix "$root" "$branch")"
}

archive_worktree_ref() {
  local root="$1"
  local branch="$2"
  printf '%s/worktree\n' "$(archive_ref_prefix "$root" "$branch")"
}

archive_head_ref() {
  local root="$1"
  local branch="$2"
  printf '%s/head\n' "$(archive_ref_prefix "$root" "$branch")"
}

archive_entries() {
  local root="$1"
  local ref branch content meta_branch="" meta_head="" meta_path="" meta_base="" line key value
  while IFS= read -r ref; do
    [ -n "$ref" ] || continue
    branch="${ref#refs/wt/archive/}"
    branch="${branch%/meta}"
    if ! content=$(git -C "$root" cat-file -p "$ref" 2>/dev/null); then
      continue
    fi
    meta_branch=""
    meta_head=""
    meta_path=""
    meta_base=""
    while IFS= read -r line || [ -n "$line" ]; do
      [ -n "$line" ] || continue
      key=${line%%=*}
      value=${line#*=}
      case "$key" in
      branch) meta_branch="$value" ;;
      head_commit) meta_head="$value" ;;
      worktree_path) meta_path="$value" ;;
      base_dir) meta_base="$value" ;;
      esac
    done <<< "$content"
    if [ -n "$meta_branch" ]; then
      branch="$meta_branch"
    fi
    [ -n "$meta_path" ] || meta_path="(unknown)"
    [ -n "$meta_head" ] || meta_head="(unknown)"
    printf '%s\t%s\t%s\t%s\n' "$branch" "$meta_path" "$meta_head" "$meta_base"
  done < <(git -C "$root" for-each-ref --format='%(refname)' refs/wt/archive | sed -n '/\/meta$/p')
}

archive_has_any_refs() {
  local root="$1"
  local branch="$2"
  local ref
  for ref in "$(archive_meta_ref "$root" "$branch")" "$(archive_index_ref "$root" "$branch")" "$(archive_worktree_ref "$root" "$branch")" "$(archive_head_ref "$root" "$branch")"; do
    if git -C "$root" show-ref --verify --quiet "$ref"; then
      return 0
    fi
  done
  return 1
}

archive_refs_complete() {
  local root="$1"
  local branch="$2"
  git -C "$root" show-ref --verify --quiet "$(archive_meta_ref "$root" "$branch")" &&
    git -C "$root" show-ref --verify --quiet "$(archive_index_ref "$root" "$branch")" &&
    git -C "$root" show-ref --verify --quiet "$(archive_worktree_ref "$root" "$branch")" &&
    git -C "$root" show-ref --verify --quiet "$(archive_head_ref "$root" "$branch")"
}

archive_delete_refs() {
  local root="$1"
  local branch="$2"
  git -C "$root" update-ref -d "$(archive_meta_ref "$root" "$branch")" 2>/dev/null || true
  git -C "$root" update-ref -d "$(archive_index_ref "$root" "$branch")" 2>/dev/null || true
  git -C "$root" update-ref -d "$(archive_worktree_ref "$root" "$branch")" 2>/dev/null || true
  git -C "$root" update-ref -d "$(archive_head_ref "$root" "$branch")" 2>/dev/null || true
}

utc_now() {
  date -u +"%Y-%m-%dT%H:%M:%SZ"
}

write_archive_metadata() {
  local root="$1"
  local branch="$2"
  local head_commit="$3"
  local worktree_path="$4"
  local base="$5"
  local archived_at="$6"
  local meta_oid
  meta_oid=$(printf 'version=1\nbranch=%s\nhead_commit=%s\nworktree_path=%s\nbase_dir=%s\narchived_at=%s\n' \
    "$branch" "$head_commit" "$worktree_path" "$base" "$archived_at" |
    git -C "$root" hash-object -w --stdin)
  git -C "$root" update-ref "$(archive_meta_ref "$root" "$branch")" "$meta_oid"
}

ARCHIVE_META_VERSION=""
ARCHIVE_META_BRANCH=""
ARCHIVE_META_HEAD_COMMIT=""
ARCHIVE_META_WORKTREE_PATH=""
ARCHIVE_META_BASE_DIR=""
ARCHIVE_META_ARCHIVED_AT=""

read_archive_metadata() {
  local root="$1"
  local branch="$2"
  local content
  if ! content=$(git -C "$root" cat-file -p "$(archive_meta_ref "$root" "$branch")" 2>/dev/null); then
    die "archive not found: '$branch'"
  fi
  ARCHIVE_META_VERSION=""
  ARCHIVE_META_BRANCH=""
  ARCHIVE_META_HEAD_COMMIT=""
  ARCHIVE_META_WORKTREE_PATH=""
  ARCHIVE_META_BASE_DIR=""
  ARCHIVE_META_ARCHIVED_AT=""
  local line key value
  while IFS= read -r line || [ -n "$line" ]; do
    [ -n "$line" ] || continue
    key=${line%%=*}
    value=${line#*=}
    case "$key" in
    version) ARCHIVE_META_VERSION="$value" ;;
    branch) ARCHIVE_META_BRANCH="$value" ;;
    head_commit) ARCHIVE_META_HEAD_COMMIT="$value" ;;
    worktree_path) ARCHIVE_META_WORKTREE_PATH="$value" ;;
    base_dir) ARCHIVE_META_BASE_DIR="$value" ;;
    archived_at) ARCHIVE_META_ARCHIVED_AT="$value" ;;
    esac
  done <<< "$content"
  [ "$ARCHIVE_META_VERSION" = "1" ] || die "unsupported archive metadata version for '$branch'"
  [ "$ARCHIVE_META_BRANCH" = "$branch" ] || die "archive metadata mismatch for '$branch'"
  [ -n "$ARCHIVE_META_HEAD_COMMIT" ] || die "archive metadata missing head_commit for '$branch'"
  [ -n "$ARCHIVE_META_WORKTREE_PATH" ] || die "archive metadata missing worktree_path for '$branch'"
}

capture_archive_trees() {
  local path="$1"
  local index_path
  if ! index_path=$(git -C "$path" rev-parse --git-path index); then
    die "failed to capture archive state"
  fi
  if ! ARCHIVE_CAPTURE_INDEX_BLOB=$(git -C "$path" hash-object -w "$index_path"); then
    die "failed to capture archive state"
  fi
  local tmp_index
  tmp_index=$(mktemp)
  if ! GIT_INDEX_FILE="$tmp_index" git -C "$path" read-tree HEAD >/dev/null; then
    rm -f "$tmp_index"
    die "failed to capture archive state"
  fi
  if ! GIT_INDEX_FILE="$tmp_index" git -C "$path" add -A >/dev/null; then
    rm -f "$tmp_index"
    die "failed to capture archive state"
  fi
  if ! ARCHIVE_CAPTURE_WORKTREE_TREE=$(GIT_INDEX_FILE="$tmp_index" git -C "$path" write-tree); then
    rm -f "$tmp_index"
    die "failed to capture archive state"
  fi
  rm -f "$tmp_index"
}

choose_unarchive_branch() {
  local root="$1"
  local branch="$2"
  local archived_head="$3"
  if git -C "$root" show-ref --verify --quiet "refs/heads/$branch"; then
    local branch_taken=0
    if find_worktree_by_branch "$root" "$branch" >/dev/null; then
      branch_taken=1
    fi
    local current_head
    current_head=$(git -C "$root" rev-parse --verify "refs/heads/$branch")
    if [ "$branch_taken" -eq 0 ] && [ "$current_head" = "$archived_head" ]; then
      printf '%s\n' "$branch"
      return
    fi
  elif branch_ref_available "$root" "$branch"; then
    printf '%s\n' "$branch"
    return
  fi
  local candidate
  if candidate=$(next_available_branch_name "$root" "${branch}-restored"); then
    printf '%s\n' "$candidate"
    return
  fi
  if [[ "$branch" == */* ]]; then
    local flat_base
    flat_base="${branch//\//-}-restored"
    if candidate=$(next_available_branch_name "$root" "$flat_base"); then
      printf '%s\n' "$candidate"
      return
    fi
  fi
  die "unable to choose restored branch name for '$branch'"
}

branch_ref_available() {
  local root="$1"
  local branch="$2"
  local ref="refs/heads/$branch"
  if git -C "$root" show-ref --verify --quiet "$ref"; then
    return 1
  fi
  if git -C "$root" for-each-ref --format='%(refname)' "$ref/" | grep -q .; then
    return 1
  fi
  local prefix="$branch"
  while [[ "$prefix" == */* ]]; do
    prefix="${prefix%/*}"
    if git -C "$root" show-ref --verify --quiet "refs/heads/$prefix"; then
      return 1
    fi
  done
  return 0
}

branch_parent_conflict() {
  local root="$1"
  local branch="$2"
  local prefix="$branch"
  while [[ "$prefix" == */* ]]; do
    prefix="${prefix%/*}"
    if git -C "$root" show-ref --verify --quiet "refs/heads/$prefix"; then
      return 0
    fi
  done
  return 1
}

next_available_branch_name() {
  local root="$1"
  local base="$2"
  if branch_parent_conflict "$root" "$base"; then
    return 1
  fi
  local candidate="$base"
  local n=2
  local limit=1000
  while ! branch_ref_available "$root" "$candidate"; do
    if [ "$n" -gt "$limit" ]; then
      return 1
    fi
    candidate="${base}-$n"
    n=$((n + 1))
  done
  printf '%s\n' "$candidate"
}

path_taken() {
  local root="$1"
  local path="$2"
  if [ -e "$path" ] || [ -L "$path" ]; then
    return 0
  fi
  if find_worktree_by_path "$root" "$path" >/dev/null; then
    return 0
  fi
  return 1
}

choose_unarchive_path() {
  local root="$1"
  local preferred="$2"
  if ! path_taken "$root" "$preferred"; then
    printf '%s\n' "$preferred"
    return
  fi
  local candidate="${preferred}-restored"
  local n=2
  while path_taken "$root" "$candidate"; do
    candidate="${preferred}-restored-$n"
    n=$((n + 1))
  done
  printf '%s\n' "$candidate"
}

restore_archive_state() {
  local path="$1"
  local worktree_tree="$2"
  local index_blob="$3"
  local index_path
  if ! index_path=$(git -C "$path" rev-parse --git-path index); then
    return 1
  fi
  if ! git -C "$path" read-tree --reset -u "$worktree_tree"; then
    return 1
  fi
  if ! git -C "$path" cat-file blob "$index_blob" >"$index_path"; then
    return 1
  fi
}

run_post_switch_hook() {
  local branch="$1"
  local path="$2"
  local hook="${GIT_WT_POST_SWITCH:-}"
  [ -n "$hook" ] || return 0
  local root
  root=$(main_worktree_path)
  WT_BRANCH="$branch" WT_PATH="$path" WT_ROOT="$root" sh -c "$hook"
}

cleanup_unarchive_failure() {
  local root="$1"
  local path="$2"
  local branch="$3"
  local delete_branch="$4"
  git -C "$root" worktree remove --force "$path" >/dev/null 2>&1 || true
  command rm -rf "$path" 2>/dev/null || true
  git -C "$root" worktree prune >/dev/null 2>&1 || true
  if [ "$delete_branch" = "1" ]; then
    git -C "$root" branch -D "$branch" >/dev/null 2>&1 || true
  fi
}

json_escape() {
  printf '%s' "$1" | sed -e 's/\\/\\\\/g' -e 's/"/\\"/g'
}

detect_jobs() {
  sysctl -n hw.logicalcpu 2>/dev/null || nproc 2>/dev/null || echo 1
}

list_ignored_files() {
  local root="$1"
  git -C "$root" ls-files --others --ignored --exclude-standard --directory | sed '/^\.git\//d'
}

list_untracked_files() {
  local root="$1"
  git -C "$root" ls-files --others --exclude-standard | sed '/^\.git\//d'
}

list_modified_files() {
  local root="$1"
  git -C "$root" ls-files --modified | sed '/^\.git\//d'
}

list_tracked_files() {
  local root="$1"
  git -C "$root" ls-files | sed '/^\.git\//d'
}

list_nested_worktree_prefixes() {
  local src="$1"
  local src_real
  src_real=$(cd "$src" && pwd -P)
  local entry
  while IFS= read -r entry; do
    [ -n "$entry" ] || continue
    local path head branch is_bare
    parse_worktree_entry "$entry"
    [ "$is_bare" = "0" ] || continue
    [ -d "$path" ] || continue
    local path_real
    path_real=$(cd "$path" && pwd -P)
    if [ "$path_real" = "$src_real" ]; then
      continue
    fi
    case "$path_real" in
    "$src_real"/*) printf '%s\n' "${path_real#"$src_real"/}" ;;
    esac
  done < <(worktree_entries "$src")
}

filter_nested_worktree_prefixes() {
  local files="$1"
  local prefixes="$2"
  if [ -z "$prefixes" ]; then
    printf '%s' "$files"
    return
  fi
  local out="" file prefix skip file_trim prefix_trim
  while IFS= read -r file; do
    [ -n "$file" ] || continue
    file_trim="${file%/}"
    skip=0
    while IFS= read -r prefix; do
      [ -n "$prefix" ] || continue
      prefix_trim="${prefix%/}"
      case "$file_trim" in
      "$prefix_trim" | "$prefix_trim"/*)
        skip=1
        break
        ;;
      esac
      case "$prefix_trim" in
      "$file_trim" | "$file_trim"/*)
        skip=1
        break
        ;;
      esac
    done <<< "$prefixes"
    [ "$skip" -eq 1 ] && continue
    out+="$file"$'\n'
  done <<< "$files"
  printf '%s' "$out"
}

prune_nested_copy_paths() {
  local files="$1"
  local out="" dirs="" file file_trim dir skip
  while IFS= read -r file; do
    [ -n "$file" ] || continue
    file_trim="${file%/}"
    skip=0
    while IFS= read -r dir; do
      [ -n "$dir" ] || continue
      case "$file_trim" in
      "$dir"/*)
        skip=1
        break
        ;;
      esac
    done <<< "$dirs"
    [ "$skip" -eq 1 ] && continue
    out+="$file"$'\n'
    if [ "$file" != "$file_trim" ]; then
      dirs+="$file_trim"$'\n'
    fi
  done <<< "$files"
  printf '%s' "$out"
}

collect_copy_files() {
  local src="$1"
  local copyignored="$2"
  local copyuntracked="$3"
  local copymodified="$4"
  local copytracked="$5"
  local sources=0
  [ "$copyignored" -eq 1 ] && sources=$((sources + 1))
  [ "$copyuntracked" -eq 1 ] && sources=$((sources + 1))
  [ "$copymodified" -eq 1 ] && sources=$((sources + 1))
  [ "$copytracked" -eq 1 ] && sources=$((sources + 1))
  local prefixes
  prefixes=$(list_nested_worktree_prefixes "$src")
  if [ "$sources" -eq 1 ]; then
    if [ "$copyignored" -eq 1 ]; then
      local ignored
      ignored=$(filter_nested_worktree_prefixes "$(list_ignored_files "$src")" "$prefixes")
      ignored=$(printf '%s' "$ignored" | sed '/^$/d' | LC_ALL=C sort -u)
      prune_nested_copy_paths "$ignored"
      return
    fi
    if [ "$copyuntracked" -eq 1 ]; then
      filter_nested_worktree_prefixes "$(list_untracked_files "$src")" "$prefixes"
      return
    fi
    if [ "$copymodified" -eq 1 ]; then
      filter_nested_worktree_prefixes "$(list_modified_files "$src")" "$prefixes"
      return
    fi
    filter_nested_worktree_prefixes "$(list_tracked_files "$src")" "$prefixes"
    return
  fi
  local files=""
  if [ "$copyignored" -eq 1 ]; then
    files+=$(list_ignored_files "$src")$'\n'
  fi
  if [ "$copyuntracked" -eq 1 ]; then
    files+=$(list_untracked_files "$src")$'\n'
  fi
  if [ "$copymodified" -eq 1 ]; then
    files+=$(list_modified_files "$src")$'\n'
  fi
  if [ "$copytracked" -eq 1 ]; then
    files+=$(list_tracked_files "$src")$'\n'
  fi
  local deduped
  deduped=$(printf '%s' "$files" | sed '/^$/d' | LC_ALL=C sort -u)
  deduped=$(filter_nested_worktree_prefixes "$deduped" "$prefixes")
  prune_nested_copy_paths "$deduped"
}

reflink_copy_file() {
  local src="$1"
  local dst="$2"
  case "$(uname)" in
  Darwin)
    cp -c "$src" "$dst" 2>/dev/null || cp "$src" "$dst" 2>/dev/null || true
    ;;
  *)
    cp --reflink=auto "$src" "$dst" 2>/dev/null || cp "$src" "$dst" 2>/dev/null || true
    ;;
  esac
}

reflink_copy_tree() {
  local src="$1"
  local dst="$2"
  mkdir -p "$dst"
  case "$(uname)" in
  Darwin)
    cp -cRP "$src/." "$dst" 2>/dev/null || cp -RP "$src/." "$dst" 2>/dev/null || true
    ;;
  *)
    cp -a --reflink=auto "$src/." "$dst" 2>/dev/null || cp -a "$src/." "$dst" 2>/dev/null || true
    ;;
  esac
}

reflink_copy_tree_no_overwrite() {
  local src="$1"
  local dst="$2"
  mkdir -p "$dst"
  case "$(uname)" in
  Darwin)
    cp -cnRP "$src/." "$dst" 2>/dev/null || cp -nRP "$src/." "$dst" 2>/dev/null || true
    ;;
  *)
    cp -a -n --reflink=auto "$src/." "$dst" 2>/dev/null || cp -a -n "$src/." "$dst" 2>/dev/null || true
    ;;
  esac
}

reflink_copy_dir_new() {
  local src="$1"
  local dst="$2"
  local src_dir="${src%/}"
  local parent
  parent=$(dirname "$dst")
  mkdir -p "$parent"
  case "$(uname)" in
  Darwin)
    cp -cRP "$src_dir" "$parent" 2>/dev/null || cp -RP "$src_dir" "$parent" 2>/dev/null || true
    ;;
  *)
    cp -a --reflink=auto "$src_dir" "$parent" 2>/dev/null || cp -a "$src_dir" "$parent" 2>/dev/null || true
    ;;
  esac
}

remove_path() {
  local path="$1"
  if [ -L "$path" ] || [ -f "$path" ]; then
    rm -f "$path" 2>/dev/null || true
    return
  fi
  if [ -d "$path" ]; then
    rm -rf "$path" 2>/dev/null || true
  fi
}

copy_symlink() {
  local src="$1"
  local dst="$2"
  local force="${3:-0}"
  local target
  target=$(readlink "$src" 2>/dev/null) || return 0
  if [ -e "$dst" ] || [ -L "$dst" ]; then
    if [ "$force" -eq 1 ]; then
      remove_path "$dst"
    else
      return 0
    fi
  fi
  mkdir -p "$(dirname "$dst")"
  ln -s "$target" "$dst" 2>/dev/null || true
}

copy_file() {
  local src="$1"
  local dst="$2"
  local force="${3:-0}"
  if [ -e "$dst" ] || [ -L "$dst" ]; then
    if [ "$force" -eq 1 ]; then
      remove_path "$dst"
    else
      return 0
    fi
  fi
  mkdir -p "$(dirname "$dst")"
  reflink_copy_file "$src" "$dst"
}

copy_dir_recursive() {
  local src_dir="$1"
  local dst_dir="$2"
  local force="${3:-0}"
  local dst_exists=0
  if [ -e "$dst_dir" ] || [ -L "$dst_dir" ]; then
    dst_exists=1
    if [ -d "$dst_dir" ] && [ ! -L "$dst_dir" ]; then
      :
    elif [ "$force" -eq 1 ]; then
      remove_path "$dst_dir"
      dst_exists=0
    else
      return 0
    fi
  fi
  if [ "$dst_exists" -eq 0 ]; then
    reflink_copy_dir_new "$src_dir" "$dst_dir"
  elif [ "$force" -eq 1 ]; then
    reflink_copy_tree "$src_dir" "$dst_dir"
  else
    reflink_copy_tree_no_overwrite "$src_dir" "$dst_dir"
  fi
}

copy_tree() {
  local src_dir="$1"
  local dst_dir="$2"
  local force="${3:-0}"
  copy_dir_recursive "$src_dir" "$dst_dir" "$force"
}

copy_path() {
  local src="$1"
  local dst="$2"
  local force="${3:-0}"
  if [ -L "$src" ]; then
    copy_symlink "$src" "$dst" "$force"
  elif [ -d "$src" ]; then
    copy_tree "$src" "$dst" "$force"
  elif [ -f "$src" ]; then
    copy_file "$src" "$dst" "$force"
  fi
}

copy_entry() {
  local entry="$1" src="$2" dst="$3" force="${4:-0}" verbose="${5:-0}"
  [ -n "$entry" ] || return 0
  local entry_trim="${entry%/}"
  local srcfile="$src/$entry_trim"
  local dstfile="$dst/$entry_trim"
  [ -e "$srcfile" ] || [ -L "$srcfile" ] || return 0
  [ "$verbose" -eq 1 ] && printf '%s\n' "$entry_trim" >&2
  copy_path "$srcfile" "$dstfile" "$force"
}

copy_entries_parallel() {
  local src="$1" dst="$2" files="$3" force="${4:-0}" verbose="${5:-0}"
  local jobs
  jobs=$(detect_jobs)
  local tmpfile
  tmpfile=$(mktemp)
  printf '%s' "$files" | sed '/^$/d' > "$tmpfile"
  export -f copy_entry copy_path copy_symlink copy_tree copy_dir_recursive \
    copy_file reflink_copy_file reflink_copy_tree reflink_copy_tree_no_overwrite \
    reflink_copy_dir_new remove_path
  xargs -P "$jobs" -I{} bash -c 'copy_entry "$@"' _ {} "$src" "$dst" "$force" "$verbose" < "$tmpfile"
  rm -f "$tmpfile"
}

copy_files_to_worktree() {
  local src="$1"
  local dst="$2"
  local copyignored="$3"
  local copyuntracked="$4"
  local copymodified="$5"
  local copytracked="$6"
  local force="${7:-0}"
  local verbose="${8:-0}"
  local files
  files=$(collect_copy_files "$src" "$copyignored" "$copyuntracked" "$copymodified" "$copytracked")
  copy_entries_parallel "$src" "$dst" "$files" "$force" "$verbose"
}

copy_files_between() {
  local src="$1"
  local dst="$2"
  local copyignored="$3"
  local copyuntracked="$4"
  local copymodified="$5"
  local copytracked="$6"
  local dryrun="${7:-0}"
  local verbose="${8:-0}"
  local force="${9:-0}"
  if [ "$src" = "$dst" ] || { [ -d "$src" ] && [ -d "$dst" ] && [ "$src" -ef "$dst" ]; }; then
    return 0
  fi
  if [ "$dryrun" -eq 1 ] && [ "$verbose" -eq 0 ]; then
    collect_copy_files "$src" "$copyignored" "$copyuntracked" "$copymodified" "$copytracked"
    return 0
  fi
  local files
  files=$(collect_copy_files "$src" "$copyignored" "$copyuntracked" "$copymodified" "$copytracked")
  if [ "$dryrun" -eq 1 ]; then
    local file
    while IFS= read -r file; do
      [ -z "$file" ] && continue
      local srcfile="$src/$file"
      if [ ! -e "$srcfile" ] && [ ! -L "$srcfile" ]; then
        continue
      fi
      [ "$verbose" -eq 1 ] && printf '%s\n' "$file" >&2
      printf '%s\n' "$file"
    done <<< "$files"
    return 0
  fi
  copy_entries_parallel "$src" "$dst" "$files" "$force" "$verbose"
}

open_path() {
  local branch="$1"
  local from="$2"
  local base_override="$3"
  local path_override="$4"
  local fetch="$5"
  local copyignored="${6:-0}"
  local copyuntracked="${7:-0}"
  local copymodified="${8:-0}"
  local copytracked="${9:-0}"
  local force="${10:-0}"
  local verbose="${11:-0}"
  OPEN_PATH_RESULT=""
  require_repo
  local root base path copy_src
  root=$(main_worktree_path)
  copy_src="$root"
  if [ "$copyignored" -eq 1 ] || [ "$copyuntracked" -eq 1 ] || [ "$copymodified" -eq 1 ] || [ "$copytracked" -eq 1 ]; then
    copy_src=$(copy_source_path "$root")
  fi
  base=$(base_dir "$root" "$base_override")
  if [ -n "$path_override" ]; then
    path=$(resolve_path "$root" "$path_override")
  else
    path=$(resolve_path "$root" "$base/$branch")
  fi
  local existing
  if existing=$(find_worktree_by_branch "$root" "$branch"); then
    OPEN_PATH_RESULT="$existing"
    return 0
  fi
  if git -C "$root" show-ref --verify --quiet "refs/heads/$branch"; then
    if [ -z "$path_override" ]; then
      die "branch exists without worktree: '$branch'"
    fi
    if find_worktree_by_path "$root" "$path" >/dev/null; then
      die "worktree path already in use: '$path'"
    fi
    mkdir -p "$(dirname "$path")"
    git -C "$root" worktree add "$path" "$branch" >/dev/null
    copy_files_to_worktree "$copy_src" "$path" "$copyignored" "$copyuntracked" "$copymodified" "$copytracked" "$force" "$verbose"
    OPEN_PATH_RESULT="$path"
    return 0
  fi
  if [ "$fetch" -eq 1 ]; then
    git -C "$root" fetch
  fi
  if [ -z "$from" ]; then
    from=$(git -C "$root" rev-parse HEAD)
  fi
  if ! git -C "$root" rev-parse --verify "${from}^{commit}" >/dev/null; then
    die "invalid --from ref '$from'"
  fi
  mkdir -p "$(dirname "$path")"
  git -C "$root" worktree add -b "$branch" "$path" "$from" >/dev/null
  copy_files_to_worktree "$copy_src" "$path" "$copyignored" "$copyuntracked" "$copymodified" "$copytracked" "$force" "$verbose"
  OPEN_PATH_RESULT="$path"
}

cmd_switch() {
  local from="" path_override="" fetch=0 branch=""
  local copyignored=0 copyuntracked=0 copymodified=0 copytracked=0 force=0 verbose=0
  while [ "$#" -gt 0 ]; do
    case "$1" in
    -h | --help)
      switch_usage
      exit 0
      ;;
    --from)
      [ -n "${2:-}" ] || die "missing value for --from"
      from="$2"
      shift
      ;;
    --from=*) from="${1#--from=}" ;;
    --path)
      [ -n "${2:-}" ] || die "missing value for --path"
      path_override="$2"
      shift
      ;;
    --path=*) path_override="${1#--path=}" ;;
    --fetch) fetch=1 ;;
    --copy-all) copyignored=1; copyuntracked=1; copymodified=1; copytracked=1 ;;
    --copy-ignored) copyignored=1 ;;
    --copy-untracked) copyuntracked=1 ;;
    --copy-modified) copymodified=1 ;;
    -f | --force) force=1 ;;
    -v | --verbose) verbose=1 ;;
    --*) die "unknown flag '$1'" ;;
    *) if [ -z "$branch" ]; then branch="$1"; else die "unexpected argument '$1'"; fi ;;
    esac
    shift
  done
  [ -n "$branch" ] || die "missing branch"
  local path
  open_path "$branch" "$from" "$BASE_DIR_OVERRIDE" "$path_override" "$fetch" "$copyignored" "$copyuntracked" "$copymodified" "$copytracked" "$force" "$verbose"
  path="$OPEN_PATH_RESULT"
  [ -n "$path" ] || die "failed to open workspace for '$branch'"
  if ! run_post_switch_hook "$branch" "$path"; then
    die "post-switch hook failed"
  fi
  printf '%s\n' "$path"
}

cmd_exec() {
  local from="" path_override="" fetch=0 branch=""
  while [ "$#" -gt 0 ]; do
    case "$1" in
    -h | --help)
      exec_usage
      exit 0
      ;;
    --from)
      [ -n "${2:-}" ] || die "missing value for --from"
      from="$2"
      shift
      ;;
    --from=*) from="${1#--from=}" ;;
    --path)
      [ -n "${2:-}" ] || die "missing value for --path"
      path_override="$2"
      shift
      ;;
    --path=*) path_override="${1#--path=}" ;;
    --fetch) fetch=1 ;;
    --) shift; break ;;
    --*) die "unknown flag '$1'" ;;
    *)
      if [ -z "$branch" ]; then
        branch="$1"
      else
        die "missing -- before command"
      fi
      ;;
    esac
    shift
  done
  [ -n "$branch" ] || die "missing branch"
  [ "$#" -gt 0 ] || die "missing command"
  local path
  open_path "$branch" "$from" "$BASE_DIR_OVERRIDE" "$path_override" "$fetch"
  path="$OPEN_PATH_RESULT"
  [ -n "$path" ] || die "failed to open workspace for '$branch'"
  cd "$path"
  exec "$@"
}

cmd_sync() {
  local copyignored=0 copyuntracked=0 copymodified=0 copytracked=0 dryrun=0 verbose=0 force=0
  local from_branch="" to_branch=""
  while [ "$#" -gt 0 ]; do
    case "$1" in
    -h | --help)
      sync_usage
      exit 0
      ;;
    --copy-all) copyignored=1; copyuntracked=1; copymodified=1; copytracked=1 ;;
    --copy-ignored) copyignored=1 ;;
    --copy-untracked) copyuntracked=1 ;;
    --copy-modified) copymodified=1 ;;
    -f | --force) force=1 ;;
    -v | --verbose) verbose=1 ;;
    -n | --dry-run) dryrun=1 ;;
    --)
      shift
      break
      ;;
    --*) die "unknown flag '$1'" ;;
    *)
      if [ -z "$from_branch" ]; then
        from_branch="$1"
      elif [ -z "$to_branch" ]; then
        to_branch="$1"
      else
        die "unexpected argument '$1'"
      fi
      ;;
    esac
    shift
  done
  for arg in "$@"; do
    if [ -z "$from_branch" ]; then
      from_branch="$arg"
    elif [ -z "$to_branch" ]; then
      to_branch="$arg"
    else
      die "unexpected argument '$arg'"
    fi
  done
  if [ -n "$from_branch" ] && [ -z "$to_branch" ]; then
    die "missing destination branch"
  fi
  if [ -z "$from_branch" ] && [ -n "$to_branch" ]; then
    die "missing source branch"
  fi
  require_repo
  if [ "$copyignored" -eq 0 ] && [ "$copyuntracked" -eq 0 ] && [ "$copymodified" -eq 0 ] && [ "$copytracked" -eq 0 ]; then
    die "missing copy flag"
  fi
  local root src dst
  root=$(main_worktree_path)
  if [ -z "$from_branch" ]; then
    src=$(copy_source_path "$root")
    if dst=$(git rev-parse --show-toplevel 2>/dev/null); then
      find_worktree_by_path "$root" "$dst" >/dev/null || die "current directory is not a worktree"
    else
      dst="$src"
    fi
  else
    if ! src=$(find_worktree_by_branch "$root" "$from_branch"); then
      die "workspace not found: '$from_branch'"
    fi
    if ! dst=$(find_worktree_by_branch "$root" "$to_branch"); then
      die "workspace not found: '$to_branch'"
    fi
  fi
  copy_files_between "$src" "$dst" "$copyignored" "$copyuntracked" "$copymodified" "$copytracked" "$dryrun" "$verbose" "$force"
}

cmd_ls() {
  local plain=0 json=0
  while [ "$#" -gt 0 ]; do
    case "$1" in
    -h | --help)
      ls_usage
      exit 0
      ;;
    --plain) plain=1 ;;
    --json) json=1 ;;
    --*) die "unknown flag '$1'" ;;
    *) die "unexpected argument '$1'" ;;
    esac
    shift
  done
  require_repo
  local root base
  root=$(main_worktree_path)
  if [ "$plain" -eq 1 ] && [ "$json" -eq 1 ]; then
    die "cannot use --plain and --json together"
  fi
  local mode="table"
  if [ "$plain" -eq 1 ]; then
    mode="plain"
  elif [ "$json" -eq 1 ]; then
    mode="json"
  elif [ ! -t 1 ]; then
    mode="plain"
  fi
  local entries archived_entries
  entries=$(worktree_entries "$root")
  archived_entries=$(archive_entries "$root")
  local filtered=""
  if [ -n "$BASE_DIR_OVERRIDE" ]; then
    base=$(base_dir "$root" "$BASE_DIR_OVERRIDE")
    while IFS= read -r entry; do
      [ -n "$entry" ] || continue
      local path head branch is_bare
      parse_worktree_entry "$entry"
      if [ "$is_bare" = "1" ]; then
        filtered+="(bare)"$'\t'"$path"$'\t'"$head"$'\t'"1"$'\t'"0"$'\n'
        continue
      fi
      case "$path" in
      "$base"/*)
        filtered+="$branch"$'\t'"$path"$'\t'"$head"$'\t'"0"$'\t'"0"$'\n'
        ;;
      esac
    done <<<"$entries"
    while IFS= read -r entry; do
      [ -n "$entry" ] || continue
      local branch path head archived_base rest
      branch=${entry%%$'\t'*}
      rest=${entry#*$'\t'}
      path=${rest%%$'\t'*}
      rest=${rest#*$'\t'}
      head=${rest%%$'\t'*}
      archived_base=${rest#*$'\t'}
      case "$path" in
      "$base"/*)
        filtered+="$branch"$'\t'"$path"$'\t'"$head"$'\t'"0"$'\t'"1"$'\n'
        continue
        ;;
      esac
      if [ -n "$archived_base" ] && [ "$archived_base" = "$base" ]; then
        filtered+="$branch"$'\t'"$path"$'\t'"$head"$'\t'"0"$'\t'"1"$'\n'
      fi
    done <<<"$archived_entries"
  else
    while IFS= read -r entry; do
      [ -n "$entry" ] || continue
      local path head branch is_bare
      parse_worktree_entry "$entry"
      if [ "$is_bare" = "1" ]; then
        branch="(bare)"
      fi
      filtered+="$branch"$'\t'"$path"$'\t'"$head"$'\t'"$is_bare"$'\t'"0"$'\n'
    done <<<"$entries"
    while IFS= read -r entry; do
      [ -n "$entry" ] || continue
      local branch path head rest
      branch=${entry%%$'\t'*}
      rest=${entry#*$'\t'}
      path=${rest%%$'\t'*}
      rest=${rest#*$'\t'}
      head=${rest%%$'\t'*}
      filtered+="$branch"$'\t'"$path"$'\t'"$head"$'\t'"0"$'\t'"1"$'\n'
    done <<<"$archived_entries"
  fi
  case "$mode" in
  json)
    printf '['
    local first=1
    while IFS= read -r line || [ -n "$line" ]; do
      [ -n "$line" ] || continue
      local branch path head rest is_bare is_archived is_bare_json is_archived_json
      branch=${line%%$'\t'*}
      rest=${line#*$'\t'}
      path=${rest%%$'\t'*}
      rest=${rest#*$'\t'}
      head=${rest%%$'\t'*}
      rest=${rest#*$'\t'}
      is_bare=${rest%%$'\t'*}
      is_archived=${rest#*$'\t'}
      if [ "$is_bare" = "1" ]; then
        is_bare_json="true"
      else
        is_bare_json="false"
      fi
      if [ "$is_archived" = "1" ]; then
        is_archived_json="true"
      else
        is_archived_json="false"
      fi
      if [ "$first" -eq 0 ]; then
        printf ','
      fi
      first=0
      printf '{"branch":"%s","path":"%s","head":"%s","is_bare":%s,"is_archived":%s}' "$(json_escape "$branch")" "$(json_escape "$path")" "$(json_escape "$head")" "$is_bare_json" "$is_archived_json"
    done <<<"$filtered"
    printf ']\n'
    ;;
  plain)
    while IFS= read -r line || [ -n "$line" ]; do
      [ -n "$line" ] || continue
      local branch path rest is_archived label
      branch=${line%%$'\t'*}
      rest=${line#*$'\t'}
      path=${rest%%$'\t'*}
      rest=${rest#*$'\t'}
      rest=${rest#*$'\t'}
      is_archived=${rest#*$'\t'}
      label="$branch"
      if [ "$is_archived" = "1" ]; then
        label="$branch (archived)"
      fi
      printf '%s\t%s\n' "$label" "$path"
    done <<<"$filtered"
    ;;
  table)
    while IFS= read -r line || [ -n "$line" ]; do
      [ -n "$line" ] || continue
      local branch path head rest is_archived label
      branch=${line%%$'\t'*}
      rest=${line#*$'\t'}
      path=${rest%%$'\t'*}
      rest=${rest#*$'\t'}
      head=${rest%%$'\t'*}
      rest=${rest#*$'\t'}
      is_archived=${rest#*$'\t'}
      label="$branch"
      if [ "$is_archived" = "1" ]; then
        label="$branch (archived)"
      fi
      printf '%-30s %-60s %s\n' "$label" "$path" "$head"
    done <<<"$filtered"
    ;;
  esac
}

cmd_rm() {
  local force=0 branch=""
  while [ "$#" -gt 0 ]; do
    case "$1" in
    -h | --help)
      rm_usage
      exit 0
      ;;
    -f | --force) force=1 ;;
    --*) die "unknown flag '$1'" ;;
    *) if [ -z "$branch" ]; then branch="$1"; else die "unexpected argument '$1'"; fi ;;
    esac
    shift
  done
  [ -n "$branch" ] || die "missing branch"
  require_repo
  local root path
  root=$(main_worktree_path)
  if ! path=$(find_worktree_by_branch "$root" "$branch"); then
    if [ "$force" -eq 1 ]; then
      exit 0
    fi
    die "workspace not found: '$branch'"
  fi
  if [ "$path" = "$root" ]; then
    die "cannot remove main worktree"
  fi
  if [ "$force" -eq 0 ]; then
    local dirty
    dirty=$(git -C "$path" status --porcelain)
    if [ -n "$dirty" ]; then
      if [ -t 0 ]; then
        printf "workspace '%s' has uncommitted changes. remove anyway? [y/N] " "$branch" >&2
        read -r answer
        case "$answer" in
        y | Y | yes | YES) force=1 ;;
        *) exit 1 ;;
        esac
      else
        die "workspace dirty: '$branch'"
      fi
    fi
  fi
  if [ "$force" -eq 1 ]; then
    git -C "$root" worktree remove --force "$path" 2>/dev/null || true
    command rm -rf "$path" 2>/dev/null || true
  else
    git -C "$root" worktree remove "$path"
  fi
  if [ "$force" -eq 1 ]; then
    git -C "$root" branch -D "$branch" 2>/dev/null || true
  else
    git -C "$root" branch -d "$branch"
  fi
  printf '%s\n' "$path"
}

cmd_archive() {
  local branch=""
  while [ "$#" -gt 0 ]; do
    case "$1" in
    -h | --help)
      archive_usage
      exit 0
      ;;
    --*) die "unknown flag '$1'" ;;
    *) if [ -z "$branch" ]; then branch="$1"; else die "unexpected argument '$1'"; fi ;;
    esac
    shift
  done
  [ -n "$branch" ] || die "missing branch"
  require_repo
  local root path base head_commit archived_at
  root=$(main_worktree_path)
  base=$(base_dir "$root" "$BASE_DIR_OVERRIDE")
  if ! path=$(find_worktree_by_branch "$root" "$branch"); then
    die "workspace not found: '$branch'"
  fi
  if [ "$path" = "$root" ]; then
    die "cannot archive main worktree"
  fi
  if archive_has_any_refs "$root" "$branch"; then
    die "archive already exists: '$branch'"
  fi
  if ! head_commit=$(git -C "$root" rev-parse --verify "refs/heads/$branch" 2>/dev/null); then
    die "branch not found: '$branch'"
  fi
  capture_archive_trees "$path"
  archived_at=$(utc_now)
  git -C "$root" update-ref "$(archive_index_ref "$root" "$branch")" "$ARCHIVE_CAPTURE_INDEX_BLOB"
  git -C "$root" update-ref "$(archive_worktree_ref "$root" "$branch")" "$ARCHIVE_CAPTURE_WORKTREE_TREE"
  git -C "$root" update-ref "$(archive_head_ref "$root" "$branch")" "$head_commit"
  write_archive_metadata "$root" "$branch" "$head_commit" "$path" "$base" "$archived_at"
  git -C "$root" worktree remove --force "$path" >/dev/null 2>&1 || true
  command rm -rf "$path" 2>/dev/null || true
  git -C "$root" worktree prune >/dev/null 2>&1 || true
  if find_worktree_by_branch "$root" "$branch" >/dev/null; then
    archive_delete_refs "$root" "$branch"
    die "failed to remove workspace for archive: '$branch'"
  fi
  printf '%s\n' "$path"
}

cmd_unarchive() {
  local branch="" path_override=""
  while [ "$#" -gt 0 ]; do
    case "$1" in
    -h | --help)
      unarchive_usage
      exit 0
      ;;
    --path)
      [ -n "${2:-}" ] || die "missing value for --path"
      path_override="$2"
      shift
      ;;
    --path=*) path_override="${1#--path=}" ;;
    --*) die "unknown flag '$1'" ;;
    *) if [ -z "$branch" ]; then branch="$1"; else die "unexpected argument '$1'"; fi ;;
    esac
    shift
  done
  [ -n "$branch" ] || die "missing branch"
  require_repo
  local root
  root=$(main_worktree_path)
  if ! archive_has_any_refs "$root" "$branch"; then
    die "archive not found: '$branch'"
  fi
  if ! archive_refs_complete "$root" "$branch"; then
    die "archive metadata incomplete for '$branch'"
  fi
  read_archive_metadata "$root" "$branch"
  local index_blob worktree_tree
  if ! index_blob=$(git -C "$root" rev-parse --verify "$(archive_index_ref "$root" "$branch")^{blob}" 2>/dev/null); then
    die "archive index blob missing for '$branch'"
  fi
  if ! worktree_tree=$(git -C "$root" rev-parse --verify "$(archive_worktree_ref "$root" "$branch")^{tree}" 2>/dev/null); then
    die "archive worktree tree missing for '$branch'"
  fi
  local archived_head
  if ! archived_head=$(git -C "$root" rev-parse --verify "$(archive_head_ref "$root" "$branch")^{commit}" 2>/dev/null); then
    die "archive head commit missing for '$branch'"
  fi
  if [ -n "$ARCHIVE_META_HEAD_COMMIT" ] && [ "$ARCHIVE_META_HEAD_COMMIT" != "$archived_head" ]; then
    die "archive metadata mismatch for '$branch'"
  fi
  local target_branch branch_created=0
  target_branch=$(choose_unarchive_branch "$root" "$branch" "$archived_head")
  if ! git -C "$root" show-ref --verify --quiet "refs/heads/$target_branch"; then
    git -C "$root" branch "$target_branch" "$archived_head" >/dev/null
    branch_created=1
  fi
  local preferred_path target_path
  if [ -n "$path_override" ]; then
    preferred_path=$(resolve_path "$root" "$path_override")
  else
    preferred_path=$(normalize_dir "$ARCHIVE_META_WORKTREE_PATH")
  fi
  target_path=$(choose_unarchive_path "$root" "$preferred_path")
  mkdir -p "$(dirname "$target_path")"
  if ! git -C "$root" worktree add "$target_path" "$target_branch" >/dev/null; then
    if [ "$branch_created" = "1" ]; then
      git -C "$root" branch -D "$target_branch" >/dev/null 2>&1 || true
    fi
    die "failed to recreate workspace for '$branch'"
  fi
  if ! restore_archive_state "$target_path" "$worktree_tree" "$index_blob"; then
    cleanup_unarchive_failure "$root" "$target_path" "$target_branch" "$branch_created"
    die "failed to restore archive for '$branch'"
  fi
  if ! run_post_switch_hook "$target_branch" "$target_path"; then
    cleanup_unarchive_failure "$root" "$target_path" "$target_branch" "$branch_created"
    die "post-switch hook failed"
  fi
  archive_delete_refs "$root" "$branch"
  printf '%s\n' "$target_path"
}

cmd_merge() {
  local target="" squash=1 rebase=1 commit=1
  while [ "$#" -gt 0 ]; do
    case "$1" in
      -h|--help) merge_usage; exit 0 ;;
      --no-squash) squash=0 ;;
      --no-rebase) rebase=0 ;;
      --no-commit) commit=0 ;;
      --*) die "unknown flag '$1'" ;;
      *) if [ -z "$target" ]; then target="$1"; else die "unexpected argument '$1'"; fi ;;
    esac
    shift
  done

  if [ -z "$target" ]; then
    merge_usage
    exit 1
  fi

  require_repo
  local root branch
  root=$(main_worktree_path)
  branch=$(git symbolic-ref --short HEAD 2>/dev/null) || die "not on a branch (detached HEAD)"

  git show-ref --verify --quiet "refs/heads/$target" || die "target branch '$target' not found"

  [ "$branch" != "$target" ] || die "cannot merge branch into itself"

  if [ "$commit" -eq 0 ]; then
    if [ -n "$(git status --porcelain)" ]; then
      die "uncommitted changes present (use without --no-commit)"
    fi
  fi

  if [ "$commit" -eq 1 ] && [ -n "$(git status --porcelain)" ]; then
    git add -A
    git commit -m "WIP: uncommitted changes" || die "failed to commit changes"
    printf 'committed uncommitted changes\n' >&2
  fi

  local merge_base
  merge_base=$(git merge-base HEAD "$target") || die "no common ancestor with '$target'"

  if [ "$squash" -eq 1 ]; then
    local commit_count
    commit_count=$(git rev-list --count "$merge_base..HEAD")
    if [ "$commit_count" -gt 1 ]; then
      local subjects
      subjects=$(git log --format='- %s' "$merge_base..HEAD")
      git reset --soft "$merge_base" || die "failed to reset to merge base"
      git commit -m "$(printf 'Squash %d commits\n\n%s' "$commit_count" "$subjects")" || die "failed to create squash commit"
      printf 'squashed %d commits\n' "$commit_count" >&2
    elif [ "$commit_count" -eq 1 ]; then
      printf 'single commit, nothing to squash\n' >&2
    else
      printf 'no commits ahead of %s\n' "$target" >&2
    fi
  fi

  if [ "$rebase" -eq 1 ]; then
    if ! git merge-base --is-ancestor "$target" HEAD; then
      git rebase "$target" || die "rebase failed (resolve conflicts and run: git rebase --continue)"
      printf 'rebased onto %s\n' "$target" >&2
    else
      printf 'already rebased onto %s\n' "$target" >&2
    fi
  else
    if ! git merge-base --is-ancestor "$target" HEAD; then
      die "not rebased onto '$target' (run without --no-rebase)"
    fi
  fi

  if ! git merge-base --is-ancestor "$target" HEAD; then
    die "cannot fast-forward: '$target' has commits not in HEAD"
  fi

  local head_sha
  head_sha=$(git rev-parse HEAD)
  git update-ref "refs/heads/$target" "$head_sha" || die "failed to fast-forward '$target'"
  printf 'merged to %s @ %s\n' "$target" "$(git rev-parse --short HEAD)" >&2
}

cmd_here() {
  require_repo
  local root base current
  root=$(main_worktree_path)
  base=$(base_dir "$root" "$BASE_DIR_OVERRIDE")
  current=$(git rev-parse --show-toplevel)
  case "$current" in
  "$base"/*) ;;
  *) exit 1 ;;
  esac
  local entry
  while IFS= read -r entry; do
    local path head branch is_bare
    parse_worktree_entry "$entry"
    if [ "$path" = "$current" ]; then
      if [ -n "$branch" ]; then
        printf '%s\n' "$branch"
        exit 0
      fi
    fi
  done < <(worktree_entries "$root")
  exit 1
}

cmd_base() {
  require_repo
  local root base
  root=$(main_worktree_path)
  base=$(base_dir "$root" "$BASE_DIR_OVERRIDE")
  printf '%s\n' "$base"
}

cmd_root() {
  require_repo
  local common
  common=$(common_git_dir_abs)
  if repo_is_bare "$common"; then
    printf '%s\n' "$common"
    return
  fi
  main_worktree_path
}

completion_bash() {
  local commands
  commands="switch sw exec sync ls archive unarchive rm merge here base root help completion"
  cat <<EOF
command -v wt >/dev/null 2>&1 || return 0

wt() {
  case "\$1" in
    switch|sw|unarchive)
      local i
      for i in "\$@"; do
        case "\$i" in
          -h|--help)
            command wt "\$@"
            return \$?
            ;;
        esac
      done
      local out path
      out=\$(command wt "\$@")
      local rc=\$?
      path=\$(printf '%s\n' "\$out" | tail -n 1)
      if [[ \$rc -eq 0 && -n "\$path" && -d "\$path" ]]; then
        if [[ "\$out" != "\$path" ]]; then
          printf '%s\n' "\$out" | sed '\$d'
        fi
        cd "\$path"
      else
        [[ -n "\$out" ]] && printf '%s\n' "\$out"
        return \$rc
      fi
      ;;
    *)
      command wt "\$@"
      ;;
  esac
}

__wt_branches() {
  git rev-parse --git-dir >/dev/null 2>&1 || return 0
  git for-each-ref --format='%(refname:short)' refs/heads 2>/dev/null
}

__wt_archived_branches() {
  git rev-parse --git-dir >/dev/null 2>&1 || return 0
  git for-each-ref --format='%(refname)' refs/wt/archive 2>/dev/null |
    sed -n '/\/meta$/p' |
    while IFS= read -r ref; do
      git cat-file -p "\$ref" 2>/dev/null | sed -n 's/^branch=//p' | head -n 1
    done | sed '/^$/d' | sort -u
}

_wt_complete() {
  local cur prev cmd
  cur="\${COMP_WORDS[COMP_CWORD]}"
  prev="\${COMP_WORDS[COMP_CWORD-1]}"
  cmd=""
  compopt +o default +o bashdefault 2>/dev/null
  local commands="$commands"
  local flags=""
  local i
  local global_flags="--base-dir -h --help"
  for i in "\${COMP_WORDS[@]}"; do
    if [ "\$i" = "--" ]; then
      return 0
    fi
  done
  if [ "\$prev" = "--base-dir" ]; then
    return 0
  fi
  i=1
  while [ "\$i" -lt "\$COMP_CWORD" ]; do
    local word="\${COMP_WORDS[\$i]}"
    case "\$word" in
      --base-dir)
        i=\$((i + 2))
        ;;
      --base-dir=*)
        i=\$((i + 1))
        ;;
      -h|--help)
        i=\$((i + 1))
        ;;
      --*)
        i=\$((i + 1))
        ;;
      *)
        cmd="\$word"
        break
        ;;
    esac
  done
  if [ -z "\$cmd" ]; then
    COMPREPLY=( \$(compgen -W "\$global_flags \$commands" -- "\$cur") )
    return 0
  fi
  case "\$cmd" in
    switch|sw)
      flags="--from --path --fetch --copy-all --copy-ignored --copy-untracked --copy-modified -f --force -v --verbose -h --help"
      case "\$prev" in
        --from|--path) return 0 ;;
      esac
      COMPREPLY=( \$(compgen -W "\$flags \$(__wt_branches)" -- "\$cur") )
      ;;
    exec)
      flags="--from --path --fetch -h --help --"
      case "\$prev" in
        --from|--path|--) return 0 ;;
      esac
      if [ "\$COMP_CWORD" -eq 2 ]; then
        COMPREPLY=( \$(compgen -W "\$(__wt_branches)" -- "\$cur") )
      else
        COMPREPLY=( \$(compgen -W "\$flags" -- "\$cur") )
      fi
      ;;
    sync)
      flags="--copy-all --copy-ignored --copy-untracked --copy-modified -f --force -v --verbose -n --dry-run -h --help"
      COMPREPLY=( \$(compgen -W "\$flags \$(__wt_branches)" -- "\$cur") )
      ;;
    archive)
      flags="-h --help"
      COMPREPLY=( \$(compgen -W "\$flags \$(__wt_branches)" -- "\$cur") )
      ;;
    unarchive)
      flags="--path -h --help"
      case "\$prev" in
        --path) return 0 ;;
      esac
      COMPREPLY=( \$(compgen -W "\$flags \$(__wt_archived_branches)" -- "\$cur") )
      ;;
    rm)
      flags="-f --force -h --help"
      COMPREPLY=( \$(compgen -W "\$flags \$(__wt_branches)" -- "\$cur") )
      ;;
    merge)
      flags="--no-squash --no-rebase --no-commit -h --help"
      COMPREPLY=( \$(compgen -W "\$flags \$(__wt_branches)" -- "\$cur") )
      ;;
    ls)
      flags="--plain --json -h --help"
      COMPREPLY=( \$(compgen -W "\$flags" -- "\$cur") )
      ;;
    here|base|root)
      flags="-h --help"
      COMPREPLY=( \$(compgen -W "\$flags" -- "\$cur") )
      ;;
    help)
      flags="switch sw exec sync ls archive unarchive rm merge here base root help completion"
      COMPREPLY=( \$(compgen -W "\$flags" -- "\$cur") )
      ;;
    completion)
      flags="bash zsh fish"
      COMPREPLY=( \$(compgen -W "\$flags" -- "\$cur") )
      ;;
  esac
}

complete -F _wt_complete wt
EOF
}

completion_zsh() {
  cat <<EOF
command -v wt >/dev/null 2>&1 || return 0

wt() {
  case "\$1" in
    switch|sw|unarchive)
      local i
      for i in "\$@"; do
        case "\$i" in
          -h|--help)
            command wt "\$@"
            return \$?
            ;;
        esac
      done
      local out path
      out=\$(command wt "\$@")
      local rc=\$?
      path=\$(printf '%s\n' "\$out" | tail -n 1)
      if [[ \$rc -eq 0 && -n "\$path" && -d "\$path" ]]; then
        if [[ "\$out" != "\$path" ]]; then
          printf '%s\n' "\$out" | sed '\$d'
        fi
        cd "\$path"
      else
        [[ -n "\$out" ]] && printf '%s\n' "\$out"
        return \$rc
      fi
      ;;
    *)
      command wt "\$@"
      ;;
  esac
}

__wt_branches() {
  git rev-parse --git-dir >/dev/null 2>&1 || return 0
  git for-each-ref --format='%(refname:short)' refs/heads 2>/dev/null
}

__wt_archived_branches() {
  git rev-parse --git-dir >/dev/null 2>&1 || return 0
  git for-each-ref --format='%(refname)' refs/wt/archive 2>/dev/null |
    sed -n '/\/meta$/p' |
    while IFS= read -r ref; do
      git cat-file -p "\$ref" 2>/dev/null | sed -n 's/^branch=//p' | head -n 1
    done | sed '/^$/d' | sort -u
}

_wt() {
  local -a subcmds subdescs switch_flags switch_descs exec_flags exec_descs sync_flags sync_descs ls_flags ls_descs archive_flags archive_descs unarchive_flags unarchive_descs rm_flags rm_descs merge_flags merge_descs hb_flags hb_descs global_flags global_descs
  subcmds=(switch sw exec sync ls archive unarchive rm merge here base root help completion)
  subdescs=(
    "create or open a workspace"
    "alias for switch"
    "open a workspace and run a command"
    "copy files between worktrees"
    "list workspaces"
    "save workspace state and remove worktree"
    "restore workspace from archive"
    "remove a workspace"
    "squash, rebase, and merge to target"
    "print current workspace branch"
    "print base dir"
    "print main worktree path"
    "show help"
    "print shell completion"
  )
  global_flags=(--base-dir -h --help)
  global_descs=("base dir override" "show help" "show help")
  switch_flags=(--from --path --fetch --copy-all --copy-ignored --copy-untracked --copy-modified -f --force -v --verbose -h --help)
  switch_descs=("base ref for new branch" "explicit worktree path" "fetch remotes before resolving --from" "copy all files to new worktree" "copy gitignored files to new worktree" "copy untracked files to new worktree" "copy modified files to new worktree" "overwrite existing destination files" "overwrite existing destination files" "print copy progress" "print copy progress" "show help" "show help")
  exec_flags=(--from --path --fetch -h --help --)
  exec_descs=("base ref for new branch" "explicit worktree path" "fetch remotes before resolving --from" "show help" "show help" "end of flags")
  sync_flags=(--copy-all --copy-ignored --copy-untracked --copy-modified -f --force -v --verbose -n --dry-run -h --help)
  sync_descs=("copy all files" "copy gitignored files" "copy untracked files" "copy modified files" "overwrite existing destination files" "overwrite existing destination files" "print copy progress" "print copy progress" "show files that would be copied" "show files that would be copied" "show help" "show help")
  ls_flags=(--plain --json -h --help)
  ls_descs=("tab-delimited output" "JSON output" "show help" "show help")
  archive_flags=(-h --help)
  archive_descs=("show help" "show help")
  unarchive_flags=(--path -h --help)
  unarchive_descs=("explicit worktree path" "show help" "show help")
  rm_flags=(-f --force -h --help)
  rm_descs=("remove even if dirty" "remove even if dirty" "show help" "show help")
  merge_flags=(--no-squash --no-rebase --no-commit -h --help)
  merge_descs=("preserve individual commits" "skip rebase (fail if not rebased)" "skip committing uncommitted changes" "show help" "show help")
  hb_flags=(-h --help)
  hb_descs=("show help" "show help")
  if (( CURRENT == 2 )); then
    compadd -d global_descs -- \$global_flags
    compadd -d subdescs -- \$subcmds
    return 0
  fi
  local cmd=""
  local idx=2
  while (( idx <= CURRENT )); do
    local word=\${words[idx]}
    case "\$word" in
      --base-dir)
        idx=\$((idx + 2))
        ;;
      --base-dir=*)
        idx=\$((idx + 1))
        ;;
      -h|--help)
        idx=\$((idx + 1))
        ;;
      --*)
        idx=\$((idx + 1))
        ;;
      *)
        cmd=\$word
        break
        ;;
    esac
  done
  if [[ "\${words[CURRENT-1]}" == --base-dir ]]; then
    return 0
  fi
  if [[ -z "\$cmd" ]]; then
    compadd -d global_descs -- \$global_flags
    compadd -d subdescs -- \$subcmds
    return 0
  fi
  case "\$cmd" in
    switch|sw)
      if [[ "\${words[CURRENT-1]}" == --from || "\${words[CURRENT-1]}" == --path ]]; then
        return 0
      fi
      compadd -d switch_descs -- \$switch_flags
      compadd -- \${(f)"\$(__wt_branches)"}
      return 0
      ;;
    exec)
      if [[ "\${words[CURRENT-1]}" == --from || "\${words[CURRENT-1]}" == --path || "\${words[CURRENT-1]}" == -- ]]; then
        return 0
      fi
      if (( CURRENT == 3 )); then
        compadd -- \${(f)"\$(__wt_branches)"}
      else
        compadd -d exec_descs -- \$exec_flags
      fi
      return 0
      ;;
    sync)
      compadd -d sync_descs -- \$sync_flags
      compadd -- \${(f)"\$(__wt_branches)"}
      return 0
      ;;
    archive)
      compadd -d archive_descs -- \$archive_flags
      compadd -- \${(f)"\$(__wt_branches)"}
      return 0
      ;;
    unarchive)
      if [[ "\${words[CURRENT-1]}" == --path ]]; then
        return 0
      fi
      compadd -d unarchive_descs -- \$unarchive_flags
      compadd -- \${(f)"\$(__wt_archived_branches)"}
      return 0
      ;;
    rm)
      compadd -d rm_descs -- \$rm_flags
      compadd -- \${(f)"\$(__wt_branches)"}
      return 0
      ;;
    merge)
      compadd -d merge_descs -- \$merge_flags
      compadd -- \${(f)"\$(__wt_branches)"}
      return 0
      ;;
    ls)
      compadd -d ls_descs -- \$ls_flags
      return 0
      ;;
    here|base|root)
      compadd -d hb_descs -- \$hb_flags
      return 0
      ;;
    help)
      compadd -d subdescs -- \$subcmds
      return 0
      ;;
    completion)
      compadd -- bash zsh fish
      return 0
      ;;
  esac
  return 0
}

compdef _wt wt
EOF
}

completion_fish() {
  local wt_bin="$0"
  case "$wt_bin" in
  */*) wt_bin="$(cd "$(dirname "$wt_bin")" && pwd -P)/$(basename "$wt_bin")" ;;
  *) wt_bin="$(command -v "$wt_bin" 2>/dev/null || printf '%s' "$wt_bin")" ;;
  esac
  local wt_bin_escaped="${wt_bin//\'/\'\\\'\'}"
  cat <<'EOF'
type -q wt; or return

EOF
  printf "set -g __wt_bin '%s'\n\n" "$wt_bin_escaped"
  cat <<'EOF'
function wt
  if test "$argv[1]" = "switch" -o "$argv[1]" = "sw" -o "$argv[1]" = "unarchive"
    if contains -- -h $argv; or contains -- --help $argv
      command "$__wt_bin" $argv
      return $status
    end
    set -g __wt_rc 0
    set -l out (begin
      command "$__wt_bin" $argv
      set -g __wt_rc $status
    end | string collect | string trim --right)
    set -l rc $__wt_rc
    set -e __wt_rc
    set -l out_lines (string split -- "\n" $out)
    set -l path $out_lines[-1]
    if test $rc -eq 0 -a -n "$path" -a -d "$path"
      if test (count $out_lines) -gt 1
        printf '%s\n' $out_lines[1..-2]
      end
      cd "$path"
    else
      test -n "$out"; and printf '%s\n' "$out"
      return $rc
    end
  else
    command "$__wt_bin" $argv
  end
end

function __wt_branches
  command git rev-parse --git-dir >/dev/null 2>&1
  or return
  command git for-each-ref --format='%(refname:short)' refs/heads 2>/dev/null
end

function __wt_archived_branches
  command git rev-parse --git-dir >/dev/null 2>&1
  or return
  command git for-each-ref --format='%(refname)' refs/wt/archive 2>/dev/null |
    sed -n '/\/meta$/p' |
    while read -l ref
      command git cat-file -p "$ref" 2>/dev/null | sed -n 's/^branch=//p' | head -n 1
    end | sed '/^$/d' | sort -u
end

complete -c wt -f
complete -c wt -l base-dir -r -d 'base dir override'
complete -c wt -s h -l help -d 'show help'
complete -c wt -n '__fish_use_subcommand' -a switch -d 'create or open a workspace'
complete -c wt -n '__fish_use_subcommand' -a sw -d 'alias for switch'
complete -c wt -n '__fish_use_subcommand' -a exec -d 'open a workspace and run a command'
complete -c wt -n '__fish_use_subcommand' -a sync -d 'copy files between worktrees'
complete -c wt -n '__fish_use_subcommand' -a ls -d 'list workspaces'
complete -c wt -n '__fish_use_subcommand' -a archive -d 'save workspace state and remove worktree'
complete -c wt -n '__fish_use_subcommand' -a unarchive -d 'restore workspace from archive'
complete -c wt -n '__fish_use_subcommand' -a rm -d 'remove a workspace'
complete -c wt -n '__fish_use_subcommand' -a merge -d 'squash, rebase, and merge to target'
complete -c wt -n '__fish_use_subcommand' -a here -d 'print current workspace branch'
complete -c wt -n '__fish_use_subcommand' -a base -d 'print base dir'
complete -c wt -n '__fish_use_subcommand' -a root -d 'print main worktree path'
complete -c wt -n '__fish_use_subcommand' -a help -d 'show help'
complete -c wt -n '__fish_use_subcommand' -a completion -d 'print shell completion'
complete -c wt -n '__fish_seen_subcommand_from switch sw exec sync archive rm merge' -a '(__wt_branches)'
complete -c wt -n '__fish_seen_subcommand_from unarchive' -a '(__wt_archived_branches)'

complete -c wt -n '__fish_seen_subcommand_from switch sw exec' -l from -r -d 'base ref for new branch'
complete -c wt -n '__fish_seen_subcommand_from switch sw exec' -l path -r -d 'explicit worktree path'
complete -c wt -n '__fish_seen_subcommand_from switch sw exec' -l fetch -d 'fetch remotes before resolving --from'
complete -c wt -n '__fish_seen_subcommand_from switch sw exec' -s h -l help -d 'show help'
complete -c wt -n '__fish_seen_subcommand_from switch sw' -l copy-all -d 'copy all files to new worktree'
complete -c wt -n '__fish_seen_subcommand_from switch sw' -l copy-ignored -d 'copy gitignored files to new worktree'
complete -c wt -n '__fish_seen_subcommand_from switch sw' -l copy-untracked -d 'copy untracked files to new worktree'
complete -c wt -n '__fish_seen_subcommand_from switch sw' -l copy-modified -d 'copy modified files to new worktree'
complete -c wt -n '__fish_seen_subcommand_from switch sw' -s f -l force -d 'overwrite existing destination files'
complete -c wt -n '__fish_seen_subcommand_from switch sw' -s v -l verbose -d 'print copy progress'
complete -c wt -n '__fish_seen_subcommand_from sync' -l copy-all -d 'copy all files'
complete -c wt -n '__fish_seen_subcommand_from sync' -l copy-ignored -d 'copy gitignored files'
complete -c wt -n '__fish_seen_subcommand_from sync' -l copy-untracked -d 'copy untracked files'
complete -c wt -n '__fish_seen_subcommand_from sync' -l copy-modified -d 'copy modified files'
complete -c wt -n '__fish_seen_subcommand_from sync' -s f -l force -d 'overwrite existing destination files'
complete -c wt -n '__fish_seen_subcommand_from sync' -s v -l verbose -d 'print copy progress'
complete -c wt -n '__fish_seen_subcommand_from sync' -s n -l dry-run -d 'show files that would be copied'
complete -c wt -n '__fish_seen_subcommand_from sync' -s h -l help -d 'show help'

complete -c wt -n '__fish_seen_subcommand_from ls' -l plain -d 'tab-delimited output'
complete -c wt -n '__fish_seen_subcommand_from ls' -l json -d 'JSON output'
complete -c wt -n '__fish_seen_subcommand_from ls' -s h -l help -d 'show help'

complete -c wt -n '__fish_seen_subcommand_from archive' -s h -l help -d 'show help'

complete -c wt -n '__fish_seen_subcommand_from unarchive' -l path -r -d 'explicit worktree path'
complete -c wt -n '__fish_seen_subcommand_from unarchive' -s h -l help -d 'show help'

complete -c wt -n '__fish_seen_subcommand_from rm' -s f -l force -d 'remove even if dirty'
complete -c wt -n '__fish_seen_subcommand_from rm' -s h -l help -d 'show help'

complete -c wt -n '__fish_seen_subcommand_from merge' -l no-squash -d 'preserve individual commits'
complete -c wt -n '__fish_seen_subcommand_from merge' -l no-rebase -d 'skip rebase (fail if not rebased)'
complete -c wt -n '__fish_seen_subcommand_from merge' -l no-commit -d 'skip committing uncommitted changes'
complete -c wt -n '__fish_seen_subcommand_from merge' -s h -l help -d 'show help'

complete -c wt -n '__fish_seen_subcommand_from help' -a switch -d 'create or open a workspace'
complete -c wt -n '__fish_seen_subcommand_from help' -a sw -d 'alias for switch'
complete -c wt -n '__fish_seen_subcommand_from help' -a exec -d 'open a workspace and run a command'
complete -c wt -n '__fish_seen_subcommand_from help' -a sync -d 'copy files between worktrees'
complete -c wt -n '__fish_seen_subcommand_from help' -a ls -d 'list workspaces'
complete -c wt -n '__fish_seen_subcommand_from help' -a archive -d 'save workspace state and remove worktree'
complete -c wt -n '__fish_seen_subcommand_from help' -a unarchive -d 'restore workspace from archive'
complete -c wt -n '__fish_seen_subcommand_from help' -a rm -d 'remove a workspace'
complete -c wt -n '__fish_seen_subcommand_from help' -a merge -d 'squash, rebase, and merge to target'
complete -c wt -n '__fish_seen_subcommand_from help' -a here -d 'print current workspace branch'
complete -c wt -n '__fish_seen_subcommand_from help' -a base -d 'print base dir'
complete -c wt -n '__fish_seen_subcommand_from help' -a root -d 'print main worktree path'
complete -c wt -n '__fish_seen_subcommand_from help' -a help -d 'show help'
complete -c wt -n '__fish_seen_subcommand_from help' -a completion -d 'print shell completion'
complete -c wt -n '__fish_seen_subcommand_from completion' -a 'bash zsh fish'
EOF
}

cmd_completion() {
  if [ "$#" -eq 0 ]; then
    completion_usage
    exit 1
  fi
  case "$1" in
    bash) completion_bash ;;
    zsh) completion_zsh ;;
    fish) completion_fish ;;
    *) die "unknown shell '$1'" ;;
  esac
}

cmd_help() {
  if [ "$#" -eq 0 ]; then
    usage
    exit 0
  fi
  case "$1" in
  switch | sw) switch_usage ;;
  exec) exec_usage ;;
  sync) sync_usage ;;
  ls) ls_usage ;;
  archive) archive_usage ;;
  unarchive) unarchive_usage ;;
  rm) rm_usage ;;
  merge) merge_usage ;;
  here) here_usage ;;
  base) base_usage ;;
  root) root_usage ;;
  completion) completion_usage ;;
  help) usage ;;
  *) die "unknown command '$1'" ;;
  esac
}

while [ "$#" -gt 0 ]; do
  case "$1" in
  --base-dir)
    [ -n "${2:-}" ] || die "missing value for --base-dir"
    BASE_DIR_OVERRIDE="$2"
    shift 2
    ;;
  --base-dir=*)
    BASE_DIR_OVERRIDE="${1#--base-dir=}"
    shift
    ;;
  -h | --help)
    break
    ;;
  --*) die "unknown flag '$1'" ;;
  *) break ;;
  esac
done

case "${1:-}" in
"")
  usage
  exit 1
  ;;
-h | --help)
  usage
  exit 0
  ;;
help)
  shift
  cmd_help "$@"
  ;;
switch)
  shift
  cmd_switch "$@"
  ;;
sw)
  shift
  cmd_switch "$@"
  ;;
exec)
  shift
  cmd_exec "$@"
  ;;
sync)
  shift
  cmd_sync "$@"
  ;;
ls)
  shift
  cmd_ls "$@"
  ;;
archive)
  shift
  cmd_archive "$@"
  ;;
unarchive)
  shift
  cmd_unarchive "$@"
  ;;
rm)
  shift
  cmd_rm "$@"
  ;;
merge)
  shift
  cmd_merge "$@"
  ;;
here)
  shift
  cmd_here "$@"
  ;;
base)
  shift
  cmd_base "$@"
  ;;
root)
  shift
  cmd_root "$@"
  ;;
completion)
  shift
  cmd_completion "$@"
  ;;
*) die "unknown command '$1'" ;;
esac
