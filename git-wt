#!/bin/bash

usage() {
  cat <<'USAGE'
Examples:
  git-wt switch -c feature
  git-wt switch feature
  git-wt switch
  git-wt purge
  git-wt list
  git-wt help

Usage:
  git-wt <command>

Commands:
  switch  switch to a worktree and cd into it, create with -c
  purge   delete current worktree and branch, cd to main
  list (ls)  list worktrees
  help  show help for a command

Flags:
USAGE
  common_flags_usage
}

common_flags_usage() {
  cat <<'USAGE'
  -h, --help  show help
  -b, --base <dir>  set base dir (overrides GIT_WT_BASE)
USAGE
}

switch_usage() {
  cat <<'USAGE'
Examples:
  git-wt switch -c feature
  git-wt switch feature
  git-wt switch

Usage:
  git-wt switch [-c|--create] [<feature>]
Flags:
  -c, --create  create worktree
USAGE
  common_flags_usage
}

list_usage() {
  cat <<'USAGE'
Examples:
  git-wt list
  git-wt ls

Usage:
  git-wt list
Flags:
USAGE
  common_flags_usage
}

purge_usage() {
  cat <<'USAGE'
Examples:
  git-wt purge

Usage:
  git-wt purge
Flags:
USAGE
  common_flags_usage
}

parse_global_flags() {
  ARGS=()
  while [ "${#}" -gt 0 ]; do
    case "${1}" in
    -b | --base)
      if [ -z "${2}" ]; then
        echo "error: missing base dir" >&2
        usage
        exit 1
      fi
      BASE_DIR_OVERRIDE="${2}"
      shift
      ;;
    --base=*)
      BASE_DIR_OVERRIDE="${1#--base=}"
      if [ -z "${BASE_DIR_OVERRIDE}" ]; then
        echo "error: missing base dir" >&2
        usage
        exit 1
      fi
      ;;
    *)
      ARGS+=("${1}")
      ;;
    esac
    shift
  done
}

require_repo() {
  DIR=$(git rev-parse --git-dir 2>/dev/null || true)
  if [ -z "${DIR}" ]; then
    echo "error: not a git repository" >&2
    exit 1
  fi
  printf '%s\n' "${DIR}"
}

main_worktree_path() {
  GIT_DIR=$(require_repo)
  if [[ "${GIT_DIR}" == *"/worktrees/"* ]]; then
    while read -r KEY VALUE; do
      if [ "${KEY}" = "worktree" ]; then
        printf '%s\n' "${VALUE}"
        return
      fi
    done < <(git worktree list --porcelain)
  fi
  git rev-parse --show-toplevel
}

worktree_base_dir() {
  ROOT=$(main_worktree_path)
  OVERRIDE="${GIT_WT_BASE}"
  if [ -n "${BASE_DIR_OVERRIDE}" ]; then
    OVERRIDE="${BASE_DIR_OVERRIDE}"
  fi
  if [ -z "${OVERRIDE}" ]; then
    NAME=$(basename "${ROOT}")
    PARENT=$(dirname "${ROOT}")
    printf '%s\n' "${PARENT}/${NAME}-worktrees"
    return
  fi
  case "${OVERRIDE}" in
  /*)
    printf '%s\n' "${OVERRIDE}"
    ;;
  *)
    printf '%s\n' "${ROOT}/${OVERRIDE}"
    ;;
  esac
}

worktree_exists() {
  TARGET="${1}"
  while read -r KEY VALUE; do
    if [ "${KEY}" = "worktree" ] && [ "${VALUE}" = "${TARGET}" ]; then
      return 0
    fi
  done < <(git worktree list --porcelain)
  return 1
}

list_features() {
  BASE=$(worktree_base_dir)
  PREFIX="${BASE}/"
  while read -r KEY VALUE; do
    if [ "${KEY}" = "worktree" ]; then
      case "${VALUE}" in
      "${PREFIX}"*)
        printf '%s\n' "${VALUE#${PREFIX}}"
        ;;
      esac
    fi
  done < <(git worktree list --porcelain)
}

git_switch() {
  CREATE=0
  NAME=""
  while [ "${#}" -gt 0 ]; do
    case "${1}" in
    -h | --help)
      switch_usage
      exit 0
      ;;
    -c | --create)
      CREATE=1
      ;;
    *)
      if [ -z "${NAME}" ]; then
        NAME="${1}"
      else
        echo "error: unexpected argument '${1}'" >&2
        switch_usage
        exit 1
      fi
      ;;
    esac
    shift
  done

  if [ -z "${NAME}" ]; then
    if [ -t 0 ] && command -v fzf >/dev/null 2>&1; then
      NAME=$(list_features | fzf)
      if [ -z "${NAME}" ]; then
        exit 1
      fi
    else
      echo "error: missing feature name" >&2
      switch_usage
      exit 1
    fi
  fi

  BASE=$(worktree_base_dir)
  WORKTREE_PATH="${BASE}/${NAME}"
  BRANCH_NAME="${NAME}"

  if worktree_exists "${WORKTREE_PATH}"; then
    if [[ "${BASH_SOURCE[0]}" != "${0}" ]]; then
      cd "${WORKTREE_PATH}"
    else
      cd "${WORKTREE_PATH}" && exec "${SHELL:-/bin/bash}"
    fi
    exit 0
  fi

  if [ "${CREATE}" -eq 1 ]; then
    mkdir -p "${BASE}"
    if git worktree add -b "${BRANCH_NAME}" "${WORKTREE_PATH}"; then
      if [[ "${BASH_SOURCE[0]}" != "${0}" ]]; then
        cd "${WORKTREE_PATH}"
      else
        cd "${WORKTREE_PATH}" && exec "${SHELL:-/bin/bash}"
      fi
      exit 0
    fi
    exit 1
  fi

  echo "error: worktree not found '${NAME}'" >&2
  exit 1
}

git_list() {
  require_repo >/dev/null
  git worktree list
}

git_purge() {
  while [ "${#}" -gt 0 ]; do
    case "${1}" in
    -h | --help)
      purge_usage
      exit 0
      ;;
    *)
      echo "error: unexpected argument '${1}'" >&2
      purge_usage
      exit 1
      ;;
    esac
    shift
  done

  require_repo >/dev/null
  CURRENT=$(git rev-parse --show-toplevel)
  MAIN=$(main_worktree_path)

  if [ "${CURRENT}" = "${MAIN}" ]; then
    echo "error: not in a linked worktree" >&2
    exit 1
  fi

  BRANCH=$(git symbolic-ref --quiet --short HEAD || true)
  if [ -z "${BRANCH}" ]; then
    echo "error: detached HEAD" >&2
    exit 1
  fi

  cd "${MAIN}"
  git worktree remove "${CURRENT}"
  git branch -D "${BRANCH}"

  if [[ "${BASH_SOURCE[0]}" != "${0}" ]]; then
    cd "${MAIN}"
  else
    cd "${MAIN}" && exec "${SHELL:-/bin/bash}"
  fi
}

BASE_DIR_OVERRIDE=""
ARGS=()
parse_global_flags "${@}"
set -- "${ARGS[@]}"

case "${1}" in
"")
  usage
  exit 1
  ;;
-h | --help)
  usage
  exit 0
  ;;
help)
  if [ -z "${2}" ]; then
    usage
    exit 0
  fi
  case "${2}" in
  switch)
    switch_usage
    exit 0
    ;;
  purge)
    purge_usage
    exit 0
    ;;
  list)
    list_usage
    exit 0
    ;;
  -h | --help)
    usage
    exit 0
    ;;
  *)
    echo "error: unknown command '${2}'" >&2
    usage
    exit 1
    ;;
  esac
  ;;
list | ls)
  case "${2}" in
  "")
    git_list
    ;;
  -h | --help)
    list_usage
    exit 0
    ;;
  *)
    echo "error: unexpected argument '${2}'" >&2
    list_usage
    exit 1
    ;;
  esac
  ;;
switch)
  git_switch "${@:2}"
  ;;
purge)
  git_purge "${@:2}"
  ;;
*)
  echo "error: unknown command '${1}'" >&2
  usage
  exit 1
  ;;
esac
